<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Playlist Sorter</title>
    <style>
        :root {
            --primary-color: #1DB954; /* Spotify Green */
            --secondary-color: #191414; /* Spotify Black */
            --text-color: #FFFFFF;
            --light-gray: #B3B3B3;
            --button-hover: #1ED760;
            --delete-color: #E63946;
            --delete-hover: #D62828;
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        #app-container {
            display: flex;
            width: 95%;
            max-width: 1200px;
            min-height: 80vh;
            background-color: rgba(40, 40, 40, 0.8); /* Darker transparent background */
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            overflow: hidden; /* Contain children */
        }

        /* --- Login --- */
        #login-section {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%; /* Takes full width initially */
            padding: 40px;
            text-align: center;
        }

        #login-button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #login-button:hover {
            background-color: var(--button-hover);
        }

        /* --- Main App --- */
        #main-app {
            display: none; /* Hidden by default */
            flex-direction: row;
            width: 100%;
        }

        /* --- Sidebar (Keep List) --- */
        #sidebar {
            width: 250px;
            background-color: rgba(25, 20, 20, 0.7); /* Slightly darker sidebar */
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Scroll if list is long */
            border-right: 1px solid rgba(100, 100, 100, 0.5);
        }

        #sidebar h3 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--light-gray);
            padding-bottom: 10px;
        }

        #kept-songs-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
            flex-grow: 1; /* Takes available space */
        }

        #kept-songs-list li {
            font-size: 0.9em;
            padding: 5px 0;
            border-bottom: 1px solid rgba(80, 80, 80, 0.5);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #kept-songs-list li span {
            font-size: 0.8em;
            color: var(--light-gray);
            display: block;
        }

        #make-playlist-button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 12px 20px;
            border-radius: 50px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: auto; /* Pushes button to bottom */
        }

        #make-playlist-button:hover {
            background-color: var(--button-hover);
        }
        #make-playlist-button:disabled {
            background-color: var(--light-gray);
            cursor: not-allowed;
        }


        /* --- Main Content Area --- */
        #content-area {
            flex-grow: 1; /* Takes remaining space */
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* For button positioning if needed */
        }

        /* Playlist Selection & Progress */
        #playlist-selector-container {
            width: 100%;
            margin-bottom: 20px;
            text-align: center;
        }

        #playlist-selector {
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid var(--light-gray);
            background-color: var(--secondary-color);
            color: var(--text-color);
            font-size: 1em;
            max-width: 400px; /* Limit width */
        }
         #playlist-selector:disabled {
            opacity: 0.6;
         }

        #sorting-info {
            width: 100%;
            text-align: center;
            margin-bottom: 25px;
            color: var(--light-gray);
            font-size: 0.9em;
        }
        #sorting-info strong {
            color: var(--text-color);
        }
        #progress-percentage {
            font-weight: bold;
            color: var(--primary-color);
            margin-left: 10px;
        }

        /* Track Display */
        #track-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 30px; /* Space before buttons */
            min-height: 380px; /* Reserve space to prevent layout jumps */
            width: 100%; /* Ensure it takes width */
        }

        #track-cover {
            width: 250px;
            height: 250px;
            object-fit: cover;
            border-radius: 8px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            background-color: #333; /* Placeholder color */
        }

        #track-title {
            font-size: 1.4em;
            font-weight: bold;
            margin-bottom: 5px;
            max-width: 90%;
        }

        #track-artist {
            font-size: 1em;
            color: var(--light-gray);
            max-width: 90%;
        }

        #no-preview-message {
            color: var(--light-gray);
            font-style: italic;
            margin-top: 10px;
        }


        /* Control Buttons */
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin-top: auto; /* Push controls towards bottom */
        }

        .control-button {
            background-color: rgba(80, 80, 80, 0.7);
            color: var(--text-color);
            border: none;
            border-radius: 50%; /* Circular */
            width: 60px;
            height: 60px;
            font-size: 1.8em; /* Adjust arrow size */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 25px; /* Space between buttons */
        }
        .control-button:hover {
            background-color: rgba(100, 100, 100, 0.9);
        }
        .control-button:active {
            transform: scale(0.95);
        }
        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        #delete-button {
            background-color: var(--delete-color);
            width: 70px; /* Slightly larger */
            height: 70px;
            font-size: 1em; /* Text instead of icon */
            line-height: 1; /* Adjust for text centering */
            order: 0; /* Center button in flex layout */
            margin: 0 15px;
        }
        #delete-button:hover {
            background-color: var(--delete-hover);
        }

        #ignore-button { order: -1; /* Put on the left */ }
        #keep-button   { order: 1;  /* Put on the right */ }

        /* Loading / Message Overlay */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            z-index: 10;
        }
         /* Utility Classes */
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="app-container">
        <!-- Login Section -->
        <section id="login-section">
            <h1>Spotify Playlist Sorter</h1>
            <p>Log in to start sorting your playlists like Tinder!</p>
            <button id="login-button">Login with Spotify</button>
        </section>

        <!-- Main App -->
        <main id="main-app">
            <!-- Sidebar -->
            <aside id="sidebar">
                <h3>Kept Songs</h3>
                <ul id="kept-songs-list">
                    <!-- Kept songs will be added here -->
                </ul>
                <button id="make-playlist-button" disabled>Make New Playlist</button>
            </aside>

            <!-- Content Area -->
            <section id="content-area">
                <div id="playlist-selector-container">
                    <label for="playlist-selector">Select Playlist to Sort: </label>
                    <select id="playlist-selector" disabled>
                        <option value="">Loading playlists...</option>
                    </select>
                </div>

                <div id="sorting-info">
                    Sorting: <strong id="current-playlist-name">None</strong>
                    (<span id="current-song-index">0</span>/<span id="total-songs">0</span>)
                    <span id="progress-percentage">0%</span>
                </div>

                <div id="track-display">
                    <img id="track-cover" src="" alt="Track Cover Art">
                    <h2 id="track-title">Track Title</h2>
                    <p id="track-artist">Artist Name</p>
                    <p id="no-preview-message" class="hidden">No preview available for this track.</p>
                </div>

                <div id="controls">
                    <button id="ignore-button" class="control-button" title="Ignore (Left Arrow)" disabled>&#x2190;</button> <!-- Left Arrow -->
                    <button id="delete-button" class="control-button" title="Delete from Original (Backspace)" disabled>Delete</button>
                    <button id="keep-button" class="control-button" title="Keep (Right Arrow)" disabled>&#x2192;</button> <!-- Right Arrow -->
                </div>

                 <!-- Hidden Audio Player -->
                 <audio id="audio-player" preload="auto"></audio>

            </section>

             <!-- Loading/Processing Overlay -->
            <div id="loading-overlay">
                Processing...
            </div>
        </main>

    </div>

    <script>
        // --- Configuration ---
        // IMPORTANT: Replace with your actual Client ID from Spotify Developer Dashboard
        const CLIENT_ID = "b216d27a627045e4a18b9276628b62f2"; // <--- REPLACE THIS
        const REDIRECT_URI = window.location.origin + window.location.pathname; // Use the current page URL

        // Spotify API Scopes needed for the app
        const SCOPES = [
            "user-read-private",        // Read user profile
            "playlist-read-private",    // Read private playlists
            "playlist-read-collaborative", // Read collaborative playlists
            "playlist-modify-public",   // Create/modify public playlists
            "playlist-modify-private"   // Create/modify private playlists
        ].join(" ");

        const SPOTIFY_AUTHORIZE_ENDPOINT = "https://accounts.spotify.com/authorize";
        const SPOTIFY_TOKEN_ENDPOINT = "https://accounts.spotify.com/api/token";
        const SPOTIFY_API_BASE_URL = "https://api.spotify.com/v1";

        // --- State Variables ---
        let accessToken = null;
        let codeVerifier = null;
        let userId = null;
        let playlists = [];
        let selectedPlaylistId = null;
        let currentPlaylistName = "";
        let tracks = [];
        let currentTrackIndex = -1;
        let keptTracks = []; // Array to hold { track: {...}, uri: '...' } objects

        // --- UI Elements ---
        const loginSection = document.getElementById('login-section');
        const mainApp = document.getElementById('main-app');
        const loginButton = document.getElementById('login-button');
        const playlistSelector = document.getElementById('playlist-selector');
        const currentPlaylistNameEl = document.getElementById('current-playlist-name');
        const currentSongIndexEl = document.getElementById('current-song-index');
        const totalSongsEl = document.getElementById('total-songs');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const trackCoverEl = document.getElementById('track-cover');
        const trackTitleEl = document.getElementById('track-title');
        const trackArtistEl = document.getElementById('track-artist');
        const noPreviewMessageEl = document.getElementById('no-preview-message');
        const audioPlayer = document.getElementById('audio-player');
        const ignoreButton = document.getElementById('ignore-button');
        const keepButton = document.getElementById('keep-button');
        const deleteButton = document.getElementById('delete-button');
        const keptSongsListEl = document.getElementById('kept-songs-list');
        const makePlaylistButton = document.getElementById('make-playlist-button');
        const loadingOverlay = document.getElementById('loading-overlay');

        // --- PKCE Helper Functions ---
        function generateRandomString(length) {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let text = '';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            // Base64 URL encode
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        // --- Spotify API Call Helper ---
        async function spotifyApiCall(endpoint, method = 'GET', body = null, retries = 1) {
            const url = SPOTIFY_API_BASE_URL + endpoint;
            const headers = {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            };

            const config = {
                method: method,
                headers: headers
            };

            if (body) {
                config.body = JSON.stringify(body);
            }

            try {
                const response = await fetch(url, config);

                if (response.status === 401 && retries > 0) { // Unauthorized - Token likely expired
                    console.warn("Access token expired or invalid. Attempting re-authentication.");
                    // Clear stored token and redirect to login to get a fresh one
                    clearAuthData();
                    redirectToSpotifyLogin(); // This will interrupt the current flow
                    return null; // Prevent further processing with the old token
                }

                 if (!response.ok) {
                    const errorData = await response.json().catch(() => ({})); // Try to get error details
                    console.error(`Spotify API Error (${response.status}): ${response.statusText}`, errorData);
                    throw new Error(`Spotify API Error: ${response.status} ${response.statusText}`);
                }

                // Handle empty response body for 204 No Content etc.
                 if (response.status === 204 || response.headers.get('content-length') === '0') {
                    return null; // Or return true/success indicator if appropriate
                }

                return await response.json();

            } catch (error) {
                console.error(`Error making Spotify API call to ${endpoint}:`, error);
                 // Simple retry logic for potential network issues (not for 401)
                 if (retries > 0 && error.message !== 'Spotify API Error: 401 Unauthorized') {
                    console.log(`Retrying API call (${retries} retries left)...`);
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retry
                    return spotifyApiCall(endpoint, method, body, retries - 1);
                 } else {
                    showError(`Failed API call to ${endpoint}. Check console.`);
                    setLoading(false); // Ensure loading overlay is hidden on final failure
                    throw error; // Re-throw if needed or return null/error indicator
                 }
            }
        }

        // --- Authentication Flow ---
        function redirectToSpotifyLogin() {
            codeVerifier = generateRandomString(128);
            sessionStorage.setItem('spotify_code_verifier', codeVerifier); // Store for later use

            generateCodeChallenge(codeVerifier).then(codeChallenge => {
                const params = new URLSearchParams({
                    client_id: CLIENT_ID,
                    response_type: 'code',
                    redirect_uri: REDIRECT_URI,
                    scope: SCOPES,
                    code_challenge_method: 'S256',
                    code_challenge: codeChallenge,
                    // state: 'optional_state_string' // Optional: for CSRF protection
                });

                window.location.href = `${SPOTIFY_AUTHORIZE_ENDPOINT}?${params.toString()}`;
            });
        }

        async function fetchAccessToken(code, verifier) {
             setLoading(true, "Authenticating...");
            try {
                 const params = new URLSearchParams({
                    client_id: CLIENT_ID,
                    grant_type: 'authorization_code',
                    code: code,
                    redirect_uri: REDIRECT_URI,
                    code_verifier: verifier
                });

                const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: params.toString()
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error("Error fetching access token:", response.status, errorData);
                    throw new Error(`Token exchange failed: ${response.statusText}`);
                }

                const data = await response.json();
                accessToken = data.access_token;
                // Store token (e.g., in sessionStorage for persistence across page loads within the same session)
                sessionStorage.setItem('spotify_access_token', accessToken);
                // console.log("Access Token obtained:", accessToken); // For debugging
                initializeMainApp(); // Proceed to app initialization
            } catch (error) {
                console.error("Could not obtain access token:", error);
                showError("Failed to authenticate with Spotify. Please try logging in again.");
                clearAuthData(); // Clear potential partial auth data
                showLogin(); // Go back to login screen
            } finally {
                 setLoading(false);
                 // Clean up URL by removing code and state params
                 window.history.replaceState({}, document.title, REDIRECT_URI);
                 sessionStorage.removeItem('spotify_code_verifier'); // Clean up verifier
            }
        }

        function handleRedirect() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            const storedVerifier = sessionStorage.getItem('spotify_code_verifier');

            if (error) {
                console.error("Spotify Authorization Error:", error);
                showError(`Login failed: ${error}. Please try again.`);
                showLogin();
                 window.history.replaceState({}, document.title, REDIRECT_URI); // Clean up URL
            } else if (code && storedVerifier) {
                // We have a code and the verifier, exchange for token
                fetchAccessToken(code, storedVerifier);
            } else if (sessionStorage.getItem('spotify_access_token')) {
                 // User might have refreshed page after being logged in
                 accessToken = sessionStorage.getItem('spotify_access_token');
                 console.log("Found existing access token in session storage.");
                 initializeMainApp();
            } else {
                // No code, no token - show login screen
                showLogin();
            }
        }

         function clearAuthData() {
             accessToken = null;
             codeVerifier = null;
             sessionStorage.removeItem('spotify_access_token');
             sessionStorage.removeItem('spotify_code_verifier');
         }

         function logout() {
             clearAuthData();
             resetAppState();
             showLogin();
             window.location.reload(); // Force clean state
         }

        // --- App Initialization and UI Updates ---
        function showLogin() {
            loginSection.style.display = 'flex';
            mainApp.style.display = 'none';
        }

        function showMainApp() {
            loginSection.style.display = 'none';
            mainApp.style.display = 'flex';
        }

         function setLoading(isLoading, message = "Loading...") {
             if (isLoading) {
                 loadingOverlay.textContent = message;
                 loadingOverlay.style.display = 'flex';
             } else {
                 loadingOverlay.style.display = 'none';
             }
             // Disable/enable interactions during loading
             playlistSelector.disabled = isLoading;
             ignoreButton.disabled = isLoading || currentTrackIndex < 0 || currentTrackIndex >= tracks.length;
             keepButton.disabled = isLoading || currentTrackIndex < 0 || currentTrackIndex >= tracks.length;
             deleteButton.disabled = isLoading || currentTrackIndex < 0 || currentTrackIndex >= tracks.length;
             makePlaylistButton.disabled = isLoading || keptTracks.length === 0;
         }

         function showError(message) {
             alert(`Error: ${message}`); // Simple error display
             console.error("App Error:", message);
         }

        async function initializeMainApp() {
             setLoading(true, "Fetching user data...");
             showMainApp();
             try {
                 const userData = await spotifyApiCall('/me');
                 if (!userData) return; // API call failed or token expired
                 userId = userData.id;
                 console.log("User ID:", userId);
                 await loadPlaylists();
             } catch (error) {
                 showError("Failed to load user data. Please try logging in again.");
                 logout(); // Go back to login on critical failure
             } finally {
                 setLoading(false);
             }
         }

        async function loadPlaylists() {
             setLoading(true, "Fetching playlists...");
             playlistSelector.disabled = true;
             playlistSelector.innerHTML = '<option value="">Loading playlists...</option>';
             playlists = [];
             let url = '/me/playlists?limit=50'; // Get up to 50 playlists at a time
             let hasMore = true;

             try {
                 while (url && hasMore) {
                     const data = await spotifyApiCall(url);
                     if (!data) { // API call failed or token expired
                         hasMore = false;
                         break;
                     }
                     playlists = playlists.concat(data.items);
                     url = data.next ? data.next.replace(SPOTIFY_API_BASE_URL, '') : null; // Get relative URL for next page
                     if (!url) hasMore = false;
                 }

                playlistSelector.innerHTML = '<option value="">-- Select a Playlist --</option>';
                playlists.forEach(playlist => {
                    // Only include playlists the user owns or collaborative ones they can modify
                    if (playlist.owner.id === userId || playlist.collaborative) {
                        const option = document.createElement('option');
                        option.value = playlist.id;
                        option.textContent = `${playlist.name} (${playlist.tracks.total} tracks)`;
                        playlistSelector.appendChild(option);
                    }
                });
                 playlistSelector.disabled = false;

             } catch (error) {
                 showError("Failed to load playlists.");
                 playlistSelector.innerHTML = '<option value="">Error loading playlists</option>';
             } finally {
                 setLoading(false);
             }
         }

        async function handlePlaylistSelect() {
            selectedPlaylistId = playlistSelector.value;
            if (!selectedPlaylistId) {
                resetSortingArea();
                return;
            }

            const selectedPlaylist = playlists.find(p => p.id === selectedPlaylistId);
            currentPlaylistName = selectedPlaylist ? selectedPlaylist.name : "Unknown Playlist";
            currentPlaylistNameEl.textContent = currentPlaylistName;

             setLoading(true, `Loading tracks for ${currentPlaylistName}...`);
             resetSortingArea(); // Clear previous sorting state

            tracks = [];
            let url = `/playlists/${selectedPlaylistId}/tracks?fields=items(track(id,name,artists(name),album(images),preview_url,uri)),next,total&limit=100`;
             let hasMore = true;
             let totalExpected = 0;

            try {
                 while (url && hasMore) {
                     console.log("Fetching tracks from:", url); // Debugging pagination
                     const data = await spotifyApiCall(url);
                      if (!data) { // API call failed or token expired
                         hasMore = false;
                         break;
                     }
                     if (totalExpected === 0) totalExpected = data.total; // Get total on first fetch

                    // Filter out null tracks (can happen with local files?)
                    const validItems = data.items.filter(item => item.track);
                     tracks = tracks.concat(validItems);

                     url = data.next ? data.next.replace(SPOTIFY_API_BASE_URL, '') : null; // Get relative URL for next page
                     if (!url) hasMore = false;
                     setLoading(true, `Loading tracks... (${tracks.length}/${totalExpected || '?'})`);
                 }

                console.log(`Loaded ${tracks.length} tracks.`);
                if (tracks.length > 0) {
                    currentTrackIndex = 0;
                    displayTrack(currentTrackIndex);
                    enableControls();
                } else {
                     showError("This playlist appears to be empty or contains only unreadable tracks.");
                    resetSortingArea();
                }
             } catch (error) {
                 showError(`Failed to load tracks for ${currentPlaylistName}.`);
                 resetSortingArea();
             } finally {
                  setLoading(false);
             }
        }

         function resetSortingArea() {
             currentTrackIndex = -1;
             tracks = [];
             keptTracks = [];
             updateKeepListUI(); // Clear the sidebar
             updateProgress(); // Reset progress display
             // Reset track display to placeholders
             trackCoverEl.src = "";
             trackTitleEl.textContent = "Track Title";
             trackArtistEl.textContent = "Artist Name";
             noPreviewMessageEl.classList.add('hidden');
             audioPlayer.pause();
             audioPlayer.src = "";
             disableControls();
             makePlaylistButton.disabled = true;
             // Keep playlist name, but reset counts
             currentPlaylistNameEl.textContent = selectedPlaylistId ? currentPlaylistName : "None";
             currentSongIndexEl.textContent = "0";
             totalSongsEl.textContent = "0";
             progressPercentageEl.textContent = "0%";
         }

        function displayTrack(index) {
             setLoading(true, "Loading next track..."); // Briefly show loading
             if (index < 0 || index >= tracks.length) {
                console.log("End of playlist reached.");
                handleEndOfPlaylist();
                setLoading(false);
                return;
            }

            const item = tracks[index];
            const track = item.track;

             // Basic check if track data is valid
             if (!track || !track.name) {
                 console.warn("Skipping invalid track data at index:", index, item);
                 // Automatically move to the next track if current one is bad
                 currentTrackIndex++;
                 displayTrack(currentTrackIndex);
                 return;
             }


            trackTitleEl.textContent = track.name;
            trackArtistEl.textContent = track.artists.map(artist => artist.name).join(', ');

            // Find the best image (prefer ~300px, fallback to largest/first)
            let imageUrl = 'placeholder.png'; // Add a placeholder image URL if you have one
            if (track.album && track.album.images && track.album.images.length > 0) {
                 const mediumImage = track.album.images.find(img => img.width >= 250 && img.width <= 400);
                 imageUrl = mediumImage ? mediumImage.url : track.album.images[0].url;
            }
            trackCoverEl.src = imageUrl;
             trackCoverEl.alt = `Cover art for ${track.name}`;

            updateProgress();

            // Handle audio preview
            audioPlayer.pause(); // Stop previous track first
            if (track.preview_url) {
                audioPlayer.src = track.preview_url;
                noPreviewMessageEl.classList.add('hidden');
                 // Attempt to play, handle potential browser restrictions
                 audioPlayer.play().catch(error => {
                    console.warn("Audio playback failed (likely requires user interaction first):", error);
                     // Optionally show a 'click to play' button if needed, but requirements say auto-play
                 });
            } else {
                audioPlayer.src = ""; // Clear source if no preview
                noPreviewMessageEl.classList.remove('hidden');
            }

             enableControls(); // Ensure controls are enabled for the new track
             setLoading(false);
        }

        function updateProgress() {
            const total = tracks.length;
            const current = currentTrackIndex + 1; // User-facing index (1-based)
            totalSongsEl.textContent = total;
            currentSongIndexEl.textContent = total === 0 ? 0 : Math.min(current, total); // Don't exceed total if finished

            const percentage = total === 0 ? 0 : Math.round((Math.min(current, total) / total) * 100);
            progressPercentageEl.textContent = `${percentage}%`;
        }

         function enableControls() {
             ignoreButton.disabled = false;
             keepButton.disabled = false;
             deleteButton.disabled = false;
         }

         function disableControls() {
             ignoreButton.disabled = true;
             keepButton.disabled = true;
             deleteButton.disabled = true;
         }

        // --- Sorting Actions ---
        function handleIgnore() {
            console.log("Ignored:", tracks[currentTrackIndex].track.name);
            moveToNextTrack();
        }

        function handleKeep() {
             const currentItem = tracks[currentTrackIndex];
             if (currentItem && currentItem.track && currentItem.track.uri) {
                keptTracks.push({ track: currentItem.track, uri: currentItem.track.uri });
                console.log("Kept:", currentItem.track.name);
                updateKeepListUI();
                moveToNextTrack();
             } else {
                 console.error("Cannot keep track: missing track data or URI at index", currentTrackIndex);
                 showError("Could not add this track to the keep list (invalid data).");
                 moveToNextTrack(); // Still move on
             }
        }

        async function handleDelete() {
            if (currentTrackIndex < 0 || currentTrackIndex >= tracks.length) return;

            const trackToDelete = tracks[currentTrackIndex].track;
            if (!trackToDelete || !trackToDelete.uri) {
                 showError("Cannot delete track: invalid data.");
                 moveToNextTrack();
                 return;
             }

            const confirmed = confirm(`Are you sure you want to PERMANENTLY DELETE "${trackToDelete.name}" from the playlist "${currentPlaylistName}"? This cannot be undone.`);

            if (confirmed) {
                 setLoading(true, `Deleting "${trackToDelete.name}"...`);
                console.log("Deleting:", trackToDelete.name, "URI:", trackToDelete.uri);
                try {
                    const requestBody = {
                        tracks: [{ uri: trackToDelete.uri }]
                    };
                    await spotifyApiCall(`/playlists/${selectedPlaylistId}/tracks`, 'DELETE', requestBody);
                    console.log("Successfully deleted from Spotify.");

                    // Important: Remove from the local 'tracks' array to reflect the change
                     tracks.splice(currentTrackIndex, 1);
                     // Don't increment currentTrackIndex here, because the next item is now at the current index
                     // BUT, we need to update the total count display immediately
                     totalSongsEl.textContent = tracks.length;

                     // Display the *new* track at the current index (or end if last was deleted)
                     // Need to call displayTrack without incrementing index first
                     // If it was the last track, currentTrackIndex will now be equal to the new tracks.length
                     if (currentTrackIndex >= tracks.length) {
                         handleEndOfPlaylist();
                     } else {
                         displayTrack(currentTrackIndex); // Display the track that shifted into the current spot
                     }

                } catch (error) {
                    showError(`Failed to delete "${trackToDelete.name}" from the playlist. Check console.`);
                    // Don't remove locally if API call failed
                    // Still move to the next logical track for the user
                    moveToNextTrack();
                } finally {
                     setLoading(false);
                }
            } else {
                console.log("Deletion cancelled.");
            }
        }

        function moveToNextTrack() {
            currentTrackIndex++;
            if (currentTrackIndex >= tracks.length) {
                handleEndOfPlaylist();
            } else {
                displayTrack(currentTrackIndex);
            }
        }

         function handleEndOfPlaylist() {
            console.log("Finished sorting playlist!");
            trackTitleEl.textContent = "Playlist Sorted!";
            trackArtistEl.textContent = `You've reviewed all ${tracks.length} tracks.`;
            trackCoverEl.src = ""; // Clear cover
            audioPlayer.pause();
            audioPlayer.src = "";
            noPreviewMessageEl.classList.add('hidden');
            disableControls();
            updateProgress(); // Ensure progress shows 100%
             // Optional: Automatically select next playlist or give other options
             // For now, just stops.
         }

        // --- Keep List and Playlist Creation ---
        function updateKeepListUI() {
            keptSongsListEl.innerHTML = ''; // Clear list
            keptTracks.forEach((item, index) => {
                const li = document.createElement('li');
                li.textContent = `${index + 1}. ${item.track.name}`;
                 const artistSpan = document.createElement('span');
                 artistSpan.textContent = item.track.artists.map(a => a.name).join(', ');
                 li.appendChild(artistSpan);
                keptSongsListEl.appendChild(li);
            });
             makePlaylistButton.disabled = keptTracks.length === 0 || isLoading(); // Also check loading state
        }

         function isLoading() {
             return loadingOverlay.style.display === 'flex';
         }


        async function handleMakePlaylist() {
            if (keptTracks.length === 0 || !userId) {
                showError("No songs in the 'kept' list or user ID not found.");
                return;
            }

            const defaultName = `Sorted - ${currentPlaylistName}`;
            const newPlaylistName = prompt("Enter a name for the new playlist:", defaultName);

            if (!newPlaylistName || newPlaylistName.trim() === "") {
                alert("Playlist creation cancelled.");
                return;
            }

             setLoading(true, "Creating new playlist...");

            try {
                // 1. Create the new playlist
                const createPlaylistBody = {
                    name: newPlaylistName,
                    public: false, // Or true, or prompt user
                    description: `Songs kept from sorting '${currentPlaylistName}' using the Sorter App.`
                };
                const newPlaylist = await spotifyApiCall(`/users/${userId}/playlists`, 'POST', createPlaylistBody);

                if (!newPlaylist || !newPlaylist.id) {
                     throw new Error("Failed to create playlist (API response invalid).");
                 }
                const newPlaylistId = newPlaylist.id;
                console.log(`Created playlist "${newPlaylistName}" with ID: ${newPlaylistId}`);

                 setLoading(true, `Adding ${keptTracks.length} songs...`);


                // 2. Add tracks to the new playlist (in batches of 100)
                const trackUris = keptTracks.map(item => item.uri);
                const batchSize = 100;
                 let tracksAddedCount = 0;

                for (let i = 0; i < trackUris.length; i += batchSize) {
                    const batch = trackUris.slice(i, i + batchSize);
                    const addTracksBody = { uris: batch };
                     setLoading(true, `Adding songs... (${tracksAddedCount}/${keptTracks.length})`);
                    await spotifyApiCall(`/playlists/${newPlaylistId}/tracks`, 'POST', addTracksBody);
                    tracksAddedCount += batch.length;
                    console.log(`Added batch of ${batch.length} tracks.`);
                     await new Promise(resolve => setTimeout(resolve, 200)); // Small delay between batches
                }

                alert(`Successfully created playlist "${newPlaylistName}" with ${tracksAddedCount} songs!`);

                // Optional: Clear the kept list after successful creation
                // keptTracks = [];
                // updateKeepListUI();

            } catch (error) {
                showError(`Failed to create playlist or add tracks: ${error.message}. Check console.`);
            } finally {
                 setLoading(false);
            }
        }

         // --- Reset App State (e.g., for logout or full reset) ---
         function resetAppState() {
             accessToken = null;
             codeVerifier = null;
             userId = null;
             playlists = [];
             selectedPlaylistId = null;
             currentPlaylistName = "";
             resetSortingArea(); // Also clears tracks, keptTracks, UI etc.
             playlistSelector.innerHTML = '<option value="">Log in to load playlists</option>';
             playlistSelector.disabled = true;
         }


        // --- Event Listeners ---
        loginButton.addEventListener('click', redirectToSpotifyLogin);
        playlistSelector.addEventListener('change', handlePlaylistSelect);
        ignoreButton.addEventListener('click', handleIgnore);
        keepButton.addEventListener('click', handleKeep);
        deleteButton.addEventListener('click', handleDelete);
        makePlaylistButton.addEventListener('click', handleMakePlaylist);

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
             // Don't trigger shortcuts if user is typing in an input/textarea or if controls are disabled
             if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || isLoading()) {
                 return;
             }
              if (mainApp.style.display !== 'flex') return; // Only active when app is visible

            switch (event.key) {
                case 'ArrowLeft':
                    if (!ignoreButton.disabled) {
                        event.preventDefault(); // Prevent browser navigation
                        handleIgnore();
                    }
                    break;
                case 'ArrowRight':
                     if (!keepButton.disabled) {
                         event.preventDefault(); // Prevent browser navigation
                        handleKeep();
                    }
                    break;
                case 'Backspace':
                     if (!deleteButton.disabled) {
                         event.preventDefault(); // Prevent browser back navigation
                        handleDelete();
                    }
                    break;
                // Add other keys if needed
            }
        });

        // Add listener for audio errors (e.g., unsupported format, network issues)
        audioPlayer.addEventListener('error', (e) => {
             console.error("Audio Player Error:", e);
             // Check if it's because no source is set (expected when no preview)
             if (!audioPlayer.currentSrc) {
                 // This is normal if there's no preview_url, ignore specific error message
                 noPreviewMessageEl.classList.remove('hidden');
             } else {
                showError("Audio playback error. Preview might be unavailable or corrupted.");
                noPreviewMessageEl.textContent = "Audio preview error.";
                noPreviewMessageEl.classList.remove('hidden');
             }
         });

         // Add listener for when audio can play (after source is set)
         audioPlayer.addEventListener('canplay', () => {
             // This event fires when the browser can start playing the audio.
             // If auto-play failed initially due to browser policy, this is where
             // you might enable a manual play button if you decide against pure auto-play.
             // console.log("Audio ready to play.");
         });


        // --- Initial Load ---
        handleRedirect(); // Check URL for auth code/token on page load

    </script>

</body>
</html>
