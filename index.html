<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Playlist Sorter</title>
    <style>
        :root {
            --primary-color: #1DB954; /* Spotify Green */
            --secondary-color: #191414; /* Spotify Black */
            --text-color: #FFFFFF;
            --light-gray: #B3B3B3;
            --button-hover: #1ED760;
            --delete-color: #E63946;
            --delete-hover: #D62828;
            --icon-button-bg: rgba(80, 80, 80, 0.6);
            --icon-button-hover: rgba(100, 100, 100, 0.9);
        }

        html, body {
             height: 100%; /* Ensure body takes full height */
             margin: 0;
             padding: 0;
             overflow: hidden; /* Prevent body scrollbars */
        }

        body {
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: var(--secondary-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Use min-height for flexibility */
        }

        #app-container {
            display: flex;
            width: 95%;
            max-width: 1200px;
            height: 90vh; /* Set a fixed viewport height percentage */
            max-height: 800px; /* Optional: Max height in pixels */
            background-color: rgba(40, 40, 40, 0.8);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            overflow: hidden; /* Crucial: contain children */
        }

        /* --- Login --- */
        #login-section {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%; /* Fill container */
            padding: 40px;
            text-align: center;
        }

        #login-button {
            background-color: var(--primary-color);
            color: var(--text-color);
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #login-button:hover { background-color: var(--button-hover); }

        /* --- Main App --- */
        #main-app {
            display: none; /* Hidden by default */
            flex-direction: row;
            width: 100%;
            height: 100%; /* Fill container */
        }

        /* --- Sidebar (Keep List) --- */
        #sidebar {
            width: 280px;
            flex-shrink: 0;
            background-color: rgba(25, 20, 20, 0.7);
            padding: 20px;
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack children vertically */
            overflow: hidden; /* Hide overflow initially, children will handle scroll */
            border-right: 1px solid rgba(100, 100, 100, 0.5);
            height: 100%; /* Take full height of parent (#main-app) */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        #sidebar h3 {
            margin-top: 0;
            margin-bottom: 10px; /* Space below header */
            color: var(--primary-color);
            border-bottom: 1px solid var(--light-gray);
            padding-bottom: 10px;
            flex-shrink: 0; /* Prevent header shrinking */
        }

        #kept-songs-list {
            list-style: none;
            padding: 0;
            margin: 0; /* Remove default margins */
            flex-grow: 1; /* Allow list to take available vertical space */
            overflow-y: auto; /* <<< ADD SCROLLING HERE */
            overflow-x: hidden; /* Hide horizontal scrollbar */
            /* border: 1px solid red; /* Debugging border */
        }

        #kept-songs-list li {
            font-size: 0.9em;
            padding: 8px 5px;
            border-bottom: 1px solid rgba(80, 80, 80, 0.5);
            gap: 5px;
        }

        .kept-song-item-container {
             display: flex;
             justify-content: space-between;
             align-items: center;
             width: 100%;
             gap: 8px;
        }
        .kept-song-text {
            flex-grow: 1;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .kept-song-text span {
            font-size: 0.8em;
            color: var(--light-gray);
            display: block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .kept-song-buttons { display: flex; gap: 5px; flex-shrink: 0; }
        .kept-list-btn {
            background: var(--icon-button-bg); border: none; color: var(--text-color);
            border-radius: 4px; padding: 4px 6px; cursor: pointer; font-size: 0.9em;
            line-height: 1; transition: background-color 0.2s ease;
        }
        .kept-list-btn:hover { background: var(--icon-button-hover); }
        .kept-list-btn.kept-remove-btn:hover { background: var(--delete-color); }
        .kept-list-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #make-playlist-button {
            background-color: var(--primary-color); color: var(--text-color); border: none;
            padding: 12px 20px; border-radius: 50px; font-size: 1em; font-weight: bold;
            cursor: pointer; transition: background-color 0.2s ease;
            margin-top: 15px; /* Space above button */
            flex-shrink: 0; /* Prevent button shrinking */
        }
        #make-playlist-button:hover { background-color: var(--button-hover); }
        #make-playlist-button:disabled { background-color: var(--light-gray); cursor: not-allowed; }

        /* --- Main Content Area --- */
        #content-area {
            flex-grow: 1; /* Takes remaining space */
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            overflow: hidden; /* Prevent its own scrollbars unless necessary */
            height: 100%; /* Fill container */
            box-sizing: border-box; /* Include padding in height calculation */
        }

        /* Playlist Selection & Progress */
        #playlist-selector-container { width: 100%; margin-bottom: 20px; text-align: center; flex-shrink: 0;}
        #playlist-selector { padding: 10px 15px; border-radius: 5px; border: 1px solid var(--light-gray); background-color: var(--secondary-color); color: var(--text-color); font-size: 1em; max-width: 400px; }
        #playlist-selector:disabled { opacity: 0.6; }
        #sorting-info { width: 100%; text-align: center; margin-bottom: 25px; color: var(--light-gray); font-size: 0.9em; flex-shrink: 0;}
        #sorting-info strong { color: var(--text-color); }
        #progress-percentage { font-weight: bold; color: var(--primary-color); margin-left: 10px; }

        /* Track Display */
        #track-display {
            display: flex; flex-direction: column; align-items: center; text-align: center;
            margin-bottom: 30px; /* Space before controls */
            flex-shrink: 0; /* Prevent shrinking when content area is small */
             /* Removed min-height, rely on flexbox centering */
             width: 100%;
        }
        #track-cover { width: 250px; height: 250px; object-fit: cover; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); background-color: #333; }
        #track-title { font-size: 1.4em; font-weight: bold; margin-bottom: 5px; max-width: 90%; }
        #track-artist { font-size: 1em; color: var(--light-gray); max-width: 90%; }
        #no-preview-message { color: var(--light-gray); font-style: italic; margin-top: 10px; }

        /* Control Buttons */
        #controls {
            display: flex; justify-content: center; align-items: center;
            width: 100%;
            margin-top: auto; /* Push controls towards bottom of content area */
            padding-bottom: 20px; /* Add some padding at the bottom */
             flex-shrink: 0;
        }
        .control-button {
            background-color: rgba(80, 80, 80, 0.7); color: var(--text-color); border: none;
            border-radius: 50%; width: 60px; height: 60px; font-size: 1.8em; font-weight: bold;
            cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease;
            display: flex; justify-content: center; align-items: center; margin: 0 25px;
        }
        .control-button:hover { background-color: rgba(100, 100, 100, 0.9); }
        .control-button:active { transform: scale(0.95); }
        .control-button:disabled { opacity: 0.5; cursor: not-allowed; }
        #delete-button { background-color: var(--delete-color); width: 70px; height: 70px; font-size: 1em; line-height: 1; order: 0; margin: 0 15px; }
        #delete-button:hover { background-color: var(--delete-hover); }
        #ignore-button { order: -1; }
        #keep-button   { order: 1;  }

        /* Loading / Message Overlay */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75); color: white;
            display: none; justify-content: center; align-items: center;
            font-size: 1.5em; z-index: 1000; text-align: center;
        }
         /* Utility Classes */
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div id="app-container">
        <!-- Login Section -->
        <section id="login-section">
            <h1>Spotify Playlist Sorter</h1>
            <p>Log in to start sorting your playlists like Tinder!</p>
            <button id="login-button">Login with Spotify</button>
        </section>

        <!-- Main App -->
        <main id="main-app">
            <!-- Sidebar -->
            <aside id="sidebar">
                <h3>Kept Songs</h3>
                <ul id="kept-songs-list">
                    <!-- Kept songs will be added here -->
                </ul>
                <button id="make-playlist-button" disabled>Make New Playlist</button>
            </aside>

            <!-- Content Area -->
            <section id="content-area">
                <div id="playlist-selector-container">
                    <label for="playlist-selector">Select Playlist to Sort: </label>
                    <select id="playlist-selector" disabled>
                        <option value="">Loading playlists...</option>
                    </select>
                </div>

                <div id="sorting-info">
                    Sorting: <strong id="current-playlist-name">None</strong>
                    (<span id="current-song-index">0</span>/<span id="total-songs">0</span>)
                    <span id="progress-percentage">0%</span>
                </div>

                <div id="track-display">
                    <img id="track-cover" src="" alt="Track Cover Art">
                    <h2 id="track-title">Track Title</h2>
                    <p id="track-artist">Artist Name</p>
                    <p id="no-preview-message" class="hidden">No preview available for this track.</p>
                </div>

                <div id="controls">
                    <button id="ignore-button" class="control-button" title="Ignore (Left Arrow)" disabled>&#x2190;</button>
                    <button id="delete-button" class="control-button" title="Delete from Original (Backspace)" disabled>Delete</button>
                    <button id="keep-button" class="control-button" title="Keep (Right Arrow)" disabled>&#x2192;</button>
                </div>

                 <!-- Hidden Audio Player -->
                 <audio id="audio-player" preload="auto"></audio>

            </section>

        </main>
         <!-- Loading/Processing Overlay -->
         <div id="loading-overlay"> Processing... </div>
    </div>

    <script>
        // --- Configuration ---
        const CLIENT_ID = "b216d27a627045e4a18b9276628b62f2"; // <--- Your Client ID
        const REDIRECT_URI = window.location.origin + window.location.pathname;
        const SCOPES = [
            "user-read-private", "playlist-read-private", "playlist-read-collaborative",
            "playlist-modify-public", "playlist-modify-private"
        ].join(" ");
        const SPOTIFY_AUTHORIZE_ENDPOINT = "https://accounts.spotify.com/authorize";
        const SPOTIFY_TOKEN_ENDPOINT = "https://accounts.spotify.com/api/token";
        const SPOTIFY_API_BASE_URL = "https://api.spotify.com/v1";

        // --- State Variables ---
        let accessToken = null; let codeVerifier = null; let userId = null;
        let playlists = []; let selectedPlaylistId = null; let currentPlaylistName = "";
        let tracks = []; let currentTrackIndex = -1; let keptTracks = [];

        // --- UI Elements ---
        const loginSection = document.getElementById('login-section');
        const mainApp = document.getElementById('main-app');
        const loginButton = document.getElementById('login-button');
        const playlistSelector = document.getElementById('playlist-selector');
        const currentPlaylistNameEl = document.getElementById('current-playlist-name');
        const currentSongIndexEl = document.getElementById('current-song-index');
        const totalSongsEl = document.getElementById('total-songs');
        const progressPercentageEl = document.getElementById('progress-percentage');
        const trackCoverEl = document.getElementById('track-cover');
        const trackTitleEl = document.getElementById('track-title');
        const trackArtistEl = document.getElementById('track-artist');
        const noPreviewMessageEl = document.getElementById('no-preview-message');
        const audioPlayer = document.getElementById('audio-player');
        const ignoreButton = document.getElementById('ignore-button');
        const keepButton = document.getElementById('keep-button');
        const deleteButton = document.getElementById('delete-button');
        const keptSongsListEl = document.getElementById('kept-songs-list');
        const makePlaylistButton = document.getElementById('make-playlist-button');
        const loadingOverlay = document.getElementById('loading-overlay');

        // --- PKCE Helper Functions ---
        function generateRandomString(length) {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let text = '';
            for (let i = 0; i < length; i++) { text += possible.charAt(Math.floor(Math.random() * possible.length)); }
            return text;
         }
        async function generateCodeChallenge(codeVerifier) {
             const encoder = new TextEncoder(); const data = encoder.encode(codeVerifier);
             const digest = await window.crypto.subtle.digest('SHA-256', data);
             return btoa(String.fromCharCode(...new Uint8Array(digest))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
        }

        // --- Spotify API Call Helper ---
        async function spotifyApiCall(endpoint, method = 'GET', body = null, retries = 1) {
            const url = SPOTIFY_API_BASE_URL + endpoint;
            const headers = { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' };
            const config = { method: method, headers: headers };
            if (body) config.body = JSON.stringify(body);
            try {
                const response = await fetch(url, config);
                if (response.status === 401 && retries > 0) { console.warn("Access token expired or invalid. Re-authenticating."); clearAuthData(); redirectToSpotifyLogin(); return null; }
                if (!response.ok) { const errorData = await response.json().catch(() => ({})); console.error(`Spotify API Error (${response.status}): ${response.statusText}`, errorData); throw new Error(`Spotify API Error: ${response.status} ${response.statusText}`); }
                if (response.status === 204 || response.headers.get('content-length') === '0') { return null; }
                return await response.json();
            } catch (error) {
                 console.error(`Error making Spotify API call to ${endpoint}:`, error);
                 if (retries > 0 && !error.message.includes('401')) {
                    console.log(`Retrying API call (${retries} retries left)...`); await new Promise(resolve => setTimeout(resolve, 1000)); return spotifyApiCall(endpoint, method, body, retries - 1);
                 } else { showError(`Failed API call to ${endpoint}. Check console.`); setLoading(false); throw error; }
            }
        }

        // --- Authentication Flow ---
        function redirectToSpotifyLogin() {
             codeVerifier = generateRandomString(128); sessionStorage.setItem('spotify_code_verifier', codeVerifier);
             generateCodeChallenge(codeVerifier).then(codeChallenge => {
                 const params = new URLSearchParams({ client_id: CLIENT_ID, response_type: 'code', redirect_uri: REDIRECT_URI, scope: SCOPES, code_challenge_method: 'S256', code_challenge: codeChallenge });
                 window.location.href = `${SPOTIFY_AUTHORIZE_ENDPOINT}?${params.toString()}`;
             });
        }
        async function fetchAccessToken(code, verifier) {
            setLoading(true, "Authenticating...");
            try {
                 const params = new URLSearchParams({ client_id: CLIENT_ID, grant_type: 'authorization_code', code: code, redirect_uri: REDIRECT_URI, code_verifier: verifier });
                 const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: params.toString() });
                 if (!response.ok) { const errorData = await response.json().catch(() => ({})); console.error("Error fetching access token:", response.status, errorData); throw new Error(`Token exchange failed: ${response.statusText}`); }
                 const data = await response.json(); accessToken = data.access_token; sessionStorage.setItem('spotify_access_token', accessToken);
                 initializeMainApp();
            } catch (error) { console.error("Could not obtain access token:", error); showError("Failed to authenticate with Spotify. Please try logging in again."); clearAuthData(); showLogin(); }
            finally { setLoading(false); window.history.replaceState({}, document.title, REDIRECT_URI); sessionStorage.removeItem('spotify_code_verifier'); }
         }
        function handleRedirect() {
            const urlParams = new URLSearchParams(window.location.search); const code = urlParams.get('code'); const error = urlParams.get('error'); const storedVerifier = sessionStorage.getItem('spotify_code_verifier');
            if (error) { console.error("Spotify Authorization Error:", error); showError(`Login failed: ${error}. Please try again.`); showLogin(); window.history.replaceState({}, document.title, REDIRECT_URI); }
            else if (code && storedVerifier) { fetchAccessToken(code, storedVerifier); }
            else if (sessionStorage.getItem('spotify_access_token')) { accessToken = sessionStorage.getItem('spotify_access_token'); console.log("Found existing access token."); initializeMainApp(); }
            else { showLogin(); }
        }
        function clearAuthData() { accessToken = null; codeVerifier = null; sessionStorage.removeItem('spotify_access_token'); sessionStorage.removeItem('spotify_code_verifier'); }
        function logout() { clearAuthData(); resetAppState(); showLogin(); window.location.reload(); }

        // --- App Initialization and UI Updates ---
        function showLogin() { loginSection.style.display = 'flex'; mainApp.style.display = 'none'; }
        function showMainApp() { loginSection.style.display = 'none'; mainApp.style.display = 'flex'; }
        function setLoading(isLoading, message = "Loading...") {
             loadingOverlay.style.display = isLoading ? 'flex' : 'none';
             if(isLoading) loadingOverlay.textContent = message;
             const shouldDisable = isLoading || (mainApp.style.display === 'flex' && (currentTrackIndex < 0 || currentTrackIndex >= tracks.length) && tracks.length > 0); // Disable main controls also when finished
             playlistSelector.disabled = isLoading;
             ignoreButton.disabled = shouldDisable;
             keepButton.disabled = shouldDisable;
             deleteButton.disabled = shouldDisable;
             makePlaylistButton.disabled = isLoading || keptTracks.length === 0;
             document.querySelectorAll('.kept-list-btn').forEach(btn => btn.disabled = isLoading); // Disable kept list buttons too
         }
        function showError(message) { alert(`Error: ${message}`); console.error("App Error:", message); }
        async function initializeMainApp() {
            setLoading(true, "Fetching user data..."); showMainApp();
             try {
                 const userData = await spotifyApiCall('/me'); if (!userData) return; userId = userData.id; console.log("User ID:", userId); await loadPlaylists();
             } catch (error) { showError("Failed to load user data. Please try logging in again."); logout(); }
             finally { setLoading(false); }
        }
        async function loadPlaylists() {
            setLoading(true, "Fetching playlists..."); playlistSelector.disabled = true; playlistSelector.innerHTML = '<option value="">Loading playlists...</option>';
             playlists = []; let url = '/me/playlists?limit=50'; let hasMore = true;
             try {
                 while (url && hasMore) {
                     const data = await spotifyApiCall(url); if (!data) { hasMore = false; break; }
                     playlists = playlists.concat(data.items); url = data.next ? data.next.replace(SPOTIFY_API_BASE_URL, '') : null; if (!url) hasMore = false;
                 }
                playlistSelector.innerHTML = '<option value="">-- Select a Playlist --</option>';
                playlists.forEach(playlist => {
                    if (playlist.owner.id === userId || playlist.collaborative) {
                        const option = document.createElement('option'); option.value = playlist.id; option.textContent = `${playlist.name} (${playlist.tracks.total} tracks)`; playlistSelector.appendChild(option);
                    }
                });
                 playlistSelector.disabled = false;
             } catch (error) { showError("Failed to load playlists."); playlistSelector.innerHTML = '<option value="">Error loading</option>'; }
             finally { setLoading(false); }
        }
        async function handlePlaylistSelect() {
            selectedPlaylistId = playlistSelector.value; if (!selectedPlaylistId) { resetSortingArea(); return; }
            const selectedPlaylist = playlists.find(p => p.id === selectedPlaylistId); currentPlaylistName = selectedPlaylist ? selectedPlaylist.name : "Unknown";
            currentPlaylistNameEl.textContent = currentPlaylistName; setLoading(true, `Loading tracks...`); resetSortingArea(); tracks = [];
            let url = `/playlists/${selectedPlaylistId}/tracks?fields=items(track(id,name,artists(name),album(images),preview_url,uri)),next,total&limit=100`;
            let hasMore = true; let totalExpected = 0;
            try {
                 while (url && hasMore) {
                     const data = await spotifyApiCall(url); if (!data) { hasMore = false; break; }
                     if (totalExpected === 0) totalExpected = data.total;
                     const validItems = data.items.filter(item => item.track); tracks = tracks.concat(validItems);
                     url = data.next ? data.next.replace(SPOTIFY_API_BASE_URL, '') : null; if (!url) hasMore = false;
                     setLoading(true, `Loading tracks... (${tracks.length}/${totalExpected || '?'})`);
                 }
                console.log(`Loaded ${tracks.length} tracks.`);
                if (tracks.length > 0) { currentTrackIndex = 0; displayTrack(currentTrackIndex); enableControls(); }
                else { showError("Playlist empty or contains unreadable tracks."); resetSortingArea(); }
             } catch (error) { showError(`Failed to load tracks for ${currentPlaylistName}.`); resetSortingArea(); }
             finally { setLoading(false); }
        }
        function resetSortingArea() {
             currentTrackIndex = -1; tracks = []; keptTracks = []; updateKeepListUI(); updateProgress();
             trackCoverEl.src = ""; trackTitleEl.textContent = "Track Title"; trackArtistEl.textContent = "Artist Name";
             noPreviewMessageEl.classList.add('hidden'); audioPlayer.pause(); audioPlayer.src = "";
             disableControls(); makePlaylistButton.disabled = true;
             currentPlaylistNameEl.textContent = selectedPlaylistId ? currentPlaylistName : "None";
             currentSongIndexEl.textContent = "0"; totalSongsEl.textContent = "0"; progressPercentageEl.textContent = "0%";
         }

        function displayTrack(index) {
             setLoading(true, "Loading next track...");
             if (index < 0 || index >= tracks.length) {
                // ... (rest of end of playlist logic)
                setLoading(false);
                return;
            }

            const item = tracks[index];
            if (!item || !item.track) {
                // ... (rest of skipping logic)
                 moveToNextTrack();
                 return;
             }
            const track = item.track;

            // *** ADD THIS LOGGING LINE ***
            console.log(`Displaying Track #${index}:`, JSON.stringify(track, null, 2)); // Log the whole track object nicely formatted

             if (!track.name || !track.artists || !track.album) {
                // ... (rest of skipping logic)
                 moveToNextTrack();
                 return;
             }

            // ... (rest of setting title, artist, cover) ...
             trackTitleEl.textContent = track.name;
             trackArtistEl.textContent = track.artists.map(artist => artist.name).join(', ');
             // ... set cover image ...

             updateProgress();

             // Handle audio preview
             audioPlayer.pause();
             if (track.preview_url) { // Check remains the same
                 console.log(`   Found preview_url: ${track.preview_url}`); // Log if found
                 audioPlayer.src = track.preview_url;
                 noPreviewMessageEl.classList.add('hidden');
                 audioPlayer.play()
                    .then(() => { console.log("   Preview auto-play started."); })
                    .catch(error => { console.warn(`   Audio auto-play failed for "${track.name}":`, error.message); });
             } else {
                 console.log("   No preview_url found for this track."); // Log if not found
                 audioPlayer.src = "";
                 noPreviewMessageEl.classList.remove('hidden');
                 noPreviewMessageEl.textContent = "No preview available for this track.";
             }

             enableControls();
             setLoading(false);
        }

        function updateProgress() {
            const total = tracks.length; const current = currentTrackIndex + 1; totalSongsEl.textContent = total;
            currentSongIndexEl.textContent = total === 0 ? 0 : Math.min(current, total);
            const percentage = total === 0 ? 0 : Math.round((Math.min(current, total) / total) * 100); progressPercentageEl.textContent = `${percentage}%`;
        }
        function enableControls() { ignoreButton.disabled = false; keepButton.disabled = false; deleteButton.disabled = false; }
        function disableControls() { ignoreButton.disabled = true; keepButton.disabled = true; deleteButton.disabled = true; }

        // --- Sorting Actions ---
        function handleIgnore() { console.log("Ignored:", tracks[currentTrackIndex]?.track?.name || 'Track'); moveToNextTrack(); }
        function handleKeep() {
              const currentItem = tracks[currentTrackIndex];
             if (currentItem?.track?.uri) { keptTracks.push({ track: currentItem.track, uri: currentItem.track.uri }); console.log("Kept:", currentItem.track.name); updateKeepListUI(); moveToNextTrack(); }
             else { console.error("Cannot keep track: invalid data at index", currentTrackIndex); showError("Could not add track (invalid data)."); moveToNextTrack(); }
         }
        async function handleDelete() {
            if (currentTrackIndex < 0 || currentTrackIndex >= tracks.length) return;
            const trackToDeleteItem = tracks[currentTrackIndex];
             if (!trackToDeleteItem?.track?.uri) { showError("Cannot delete track: invalid data."); moveToNextTrack(); return; }
             const trackToDelete = trackToDeleteItem.track;
            const confirmed = confirm(`DELETE "${trackToDelete.name}" from "${currentPlaylistName}"?\n\nThis cannot be undone.`);
            if (confirmed) {
                 setLoading(true, `Deleting "${trackToDelete.name}"...`);
                try {
                    await spotifyApiCall(`/playlists/${selectedPlaylistId}/tracks`, 'DELETE', { tracks: [{ uri: trackToDelete.uri }] });
                    console.log("Deleted from Spotify."); tracks.splice(currentTrackIndex, 1); totalSongsEl.textContent = tracks.length;
                     if (currentTrackIndex >= tracks.length) { handleEndOfPlaylist(); } else { displayTrack(currentTrackIndex); } // Display new track at current index
                } catch (error) { showError(`Failed to delete "${trackToDelete.name}".`); moveToNextTrack(); } // Move on even if delete failed API side
                finally { setLoading(false); }
            } else { console.log("Deletion cancelled."); }
        }
        function moveToNextTrack() { currentTrackIndex++; displayTrack(currentTrackIndex); } // displayTrack handles end of list
        function handleEndOfPlaylist() {
            console.log("Finished sorting playlist!");
            trackTitleEl.textContent = "Playlist Sorted!"; trackArtistEl.textContent = `Check the 'Kept Songs' list.`;
            trackCoverEl.src = ""; audioPlayer.pause(); audioPlayer.src = ""; noPreviewMessageEl.classList.add('hidden');
            disableControls(); updateProgress(); // Ensure progress shows 100% or final state
        }

        // --- Keep List and Playlist Creation ---
        function updateKeepListUI() {
            keptSongsListEl.innerHTML = '';
            const isLoadingState = isLoading();

            keptTracks.forEach((item, index) => {
                // *** ADD THIS LOGGING LINE ***
                console.log(`Updating Kept List UI for index ${index}: Has preview_url?`, !!item.track.preview_url, item.track.name);

                const li = document.createElement('li');
                li.dataset.trackIndex = index;
                // ... (rest of creating the li content, buttons etc.) ...

                 // Make sure the play button disable logic still uses the check
                 const playBtn = document.createElement('button');
                 // ... (set classes etc.) ...
                 playBtn.disabled = isLoadingState || !item.track.preview_url; // Correct check
                 if (!item.track.preview_url) {
                     playBtn.title = 'No Preview Available';
                 } else {
                      playBtn.title = 'Play Preview';
                 }
                 // ... (append buttons etc.) ...
                 keptSongsListEl.appendChild(li);
             });
             makePlaylistButton.disabled = keptTracks.length === 0 || isLoadingState;
         }
        function handleKeptListInteraction(event) {
            const playButton = event.target.closest('.kept-play-btn'); const removeButton = event.target.closest('.kept-remove-btn');
            if (!playButton && !removeButton || isLoading()) return;
            const listItem = event.target.closest('li'); if (!listItem?.dataset?.trackIndex) return;
            const trackIndex = parseInt(listItem.dataset.trackIndex, 10);
            if (isNaN(trackIndex) || trackIndex < 0 || trackIndex >= keptTracks.length) { console.error("Invalid kept track index:", trackIndex); return; }
             const trackItem = keptTracks[trackIndex];
            if (playButton) {
                 if (trackItem.track.preview_url) { audioPlayer.pause(); audioPlayer.src = trackItem.track.preview_url; audioPlayer.play().catch(e => { console.warn("Could not play kept track preview:", e.message); alert(`Could not play preview for "${trackItem.track.name}".`); }); }
                 else { alert(`No preview available for "${trackItem.track.name}".`); }
            } else if (removeButton) { keptTracks.splice(trackIndex, 1); updateKeepListUI(); }
        }
        async function handleMakePlaylist() {
            if (keptTracks.length === 0 || !userId) { showError("No songs kept or user ID missing."); return; }
            const defaultName = `Sorted - ${currentPlaylistName}`; const newPlaylistName = prompt("Enter name for new playlist:", defaultName);
            if (!newPlaylistName?.trim()) { alert("Playlist creation cancelled."); return; }
             setLoading(true, "Creating new playlist...");
            try {
                const newPlaylist = await spotifyApiCall(`/users/${userId}/playlists`, 'POST', { name: newPlaylistName.trim(), public: false, description: `Songs kept from sorting '${currentPlaylistName}'.` });
                 if (!newPlaylist?.id) { throw new Error("Failed to create playlist (API response invalid)."); }
                 setLoading(true, `Adding ${keptTracks.length} songs...`);
                const trackUris = keptTracks.map(item => item.uri).filter(uri => uri); // Ensure no null/undefined uris
                 if (trackUris.length !== keptTracks.length) console.warn("Some kept tracks had missing URIs!");
                 if (trackUris.length > 0) {
                     const batchSize = 100; let tracksAddedCount = 0;
                     for (let i = 0; i < trackUris.length; i += batchSize) {
                         const batch = trackUris.slice(i, i + batchSize); setLoading(true, `Adding songs... (${tracksAddedCount}/${trackUris.length})`);
                         await spotifyApiCall(`/playlists/${newPlaylist.id}/tracks`, 'POST', { uris: batch }); tracksAddedCount += batch.length; await new Promise(resolve => setTimeout(resolve, 200)); // Prevent rate limiting
                     }
                     alert(`Successfully created playlist "${newPlaylistName}" with ${tracksAddedCount} songs!`);
                 } else {
                     alert(`Playlist "${newPlaylistName}" created, but no valid tracks were available to add.`);
                 }
                 // Optional: Clear list after creation
                 // keptTracks = []; updateKeepListUI();
            } catch (error) { showError(`Failed to create playlist or add tracks: ${error.message}.`); }
            finally { setLoading(false); }
        }
        function resetAppState() {
            accessToken = null; codeVerifier = null; userId = null; playlists = []; selectedPlaylistId = null; currentPlaylistName = "";
            resetSortingArea(); playlistSelector.innerHTML = '<option value="">Log in to load</option>'; playlistSelector.disabled = true;
        }
         function isLoading() { return loadingOverlay.style.display === 'flex'; }

        // --- Event Listeners ---
        loginButton.addEventListener('click', redirectToSpotifyLogin);
        playlistSelector.addEventListener('change', handlePlaylistSelect);
        ignoreButton.addEventListener('click', handleIgnore);
        keepButton.addEventListener('click', handleKeep);
        deleteButton.addEventListener('click', handleDelete);
        makePlaylistButton.addEventListener('click', handleMakePlaylist);
        keptSongsListEl.addEventListener('click', handleKeptListInteraction);

        document.addEventListener('keydown', (event) => {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || isLoading() || mainApp.style.display !== 'flex') return;
            switch (event.key) {
                case 'ArrowLeft': if (!ignoreButton.disabled) { event.preventDefault(); handleIgnore(); } break;
                case 'ArrowRight': if (!keepButton.disabled) { event.preventDefault(); handleKeep(); } break;
                case 'Backspace': if (!deleteButton.disabled) { event.preventDefault(); handleDelete(); } break;
            }
         });
        audioPlayer.addEventListener('error', (e) => {
             // Only log significant errors, not the expected 'empty src' when no preview exists
             if (audioPlayer.error && audioPlayer.error.code !== MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED && audioPlayer.currentSrc) {
                  console.error("Audio Player Error:", audioPlayer.error.code, audioPlayer.error.message, "Src:", audioPlayer.currentSrc);
             } else if (!audioPlayer.currentSrc && !noPreviewMessageEl.classList.contains('hidden')) {
                 // This is the expected state when no preview URL was provided. Quietly ignore.
             }
         });
         audioPlayer.addEventListener('canplay', () => { /* Ready to play (if src is valid) */ });

        // --- Initial Load ---
        handleRedirect();

    </script>

</body>
</html>
